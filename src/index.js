const caLib={newGrid(e,r,n){if(!Number.isInteger(e)||e<1)throw new RangeError("Chunk length must be a positive integer!");if(!Number.isInteger(r)||r<0)throw new RangeError("Dimension must be a non-negative integer!");return 0===r?n:Object.freeze({chunkLength:e,dimension:r,quiescent:n,chunks:new Map})},updateCell(e,r,n){if(!Array.isArray(r))throw new TypeError("Index must be an array, got "+typeof r);if(0===e.dimension)return n;const t=r.map((r=>Math.floor(r/e.chunkLength))),s=r.map((r=>(r%e.chunkLength+e.chunkLength)%e.chunkLength)),i=JSON.stringify(t),u=e.chunks.get(i)??this._hypercube(e.chunkLength,e.dimension,e.quiescent),o=this._immutableSet(u,s,n),h=new Map(e.chunks);return h.set(i,o),Object.freeze({...e,chunks:h})},step(e,r){if(0===e.dimension)return r(e,[],(()=>e));const{chunkLength:n,dimension:t,chunks:s,quiescent:i}=e,u=e=>{const r=e.map((e=>Math.floor(e/n))),t=e.map((e=>(e%n+n)%n)),u=JSON.stringify(r),o=s.get(u);return o?t.reduce(((e,r)=>e[r]),o):i},o=new Set;for(const e of s.keys()){const r=JSON.parse(e),n=this._neighborOffsets(t);for(const e of n){const n=r.map(((r,n)=>r+e[n]));o.add(JSON.stringify(n))}}const h=new Map;for(const e of o){const s=JSON.parse(e),o=this._mapHypercube(n,t,(e=>{const t=e.map(((e,r)=>s[r]*n+e)),i=u(t);return r(i,t,u)}));this._isHypercubeUniform(o,i)||h.set(e,o)}return Object.freeze({...e,chunks:h})},toRule(e){},_hypercube(e,r,n){return 0===r?n:Array.from({length:e},(()=>this._hypercube(e,r-1,n)))},_immutableSet(e,r,n){if(0===r.length)return n;const[t,...s]=r;if(!Array.isArray(e))throw new RangeError("Index exceeds array depth!");return e.map(((e,r)=>r===t?this._immutableSet(e,s,n):e))},_equalArray:(e,r)=>e.length===r.length&&e.every(((e,n)=>e===r[n])),_neighborOffsets(e){if(0===e)return[[]];const r=this._neighborOffsets(e-1),n=[-1,0,1];return r.flatMap((e=>n.map((r=>[...e,r]))))},_mapHypercube(e,r,n,t=[]){return 0===r?n(t):Array.from({length:e},((s,i)=>this._mapHypercube(e,r-1,n,[...t,i])))},_isHypercubeUniform(e,r){return Array.isArray(e)?e.every((e=>this._isHypercubeUniform(e,r))):e===r}};export default caLib;
